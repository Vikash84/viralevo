---
title: "Viral Genomes Analysis"
author: "Francesco Lescai and Thomas Bleazard"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    theme: readable
    highlight: tango
    toc: true
    toc_float: true
    css: nibsc_report.css
editor_options:
  chunk_output_type: console
params:
  vcf: NULL
  callers: NULL
  samples: NULL
  genome: NULL
  genemodel: NULL
  baseDir: NULL
  bamSamples: NULL
  bamFiles: NULL
  bicTree: NULL
  aicTree: NULL
  msaFasta: NULL
  msaPhylip: NULL
---


```{r, echo=FALSE, message=FALSE, error=FALSE, warning=FALSE}
library(knitr)
opts_chunk$set(message=FALSE, error=FALSE, warning=FALSE, tidy=TRUE, tidy.opts=list(blank=FALSE), cache=TRUE, cache.lazy = FALSE, echo = FALSE,  results = 'asis', fig.pos='H', fig.wide=TRUE)
```


# Introduction

This pipeline is meant to analyse viral genomes using both reference based and assembly based approaches.
The reference based approach is however our primary choice, in order to describe all potential mutations at the variant-allele fraction closest to the limit of detection.

In order to achieve the results, reported in this document, we have used the following tools:

## Reference-based approach

We have trimmed the reads, and then aligned them to the provided RefSeq reference. Subsequently, the resulting bam files have been used for variant calling with both a widely used somatic variant caller, as well as with a variant caller specifically developed for amplicon based sequencing and viral evolution analysis.
The called variants are used to generate consensus sequences.
The consensus sequences are used to infer phylogeny, analysing them compared to the reference and a number of key genomes selected in advance. The best phylogenetic tree is selected and displayed in the report.

## Assembly-based approach

In this case, the reads are assembled into contigs using a popular tool (*SPADES*), and the contigs produced from each sample are refined and ordered along a reference genome in order to create a draft assembly.
Each draft assembly is analysed using a whole-genome alignment tool, with the aim of discovering any larger genome rearrangement or structural variants.


# Results

The following results are reported by sample, and have been generated with the procedure described above. More details about the tools as well as references are provided within the methods section below.

## Read Based Variant Analysis

```{r parseInput, include=FALSE}
library(tidyverse)
vcfFiles <- strsplit(params$vcf, ",")
samples <- strsplit(params$samples, ",")
callers <- strsplit(params$callers, ",")

vcfInfo <- data.frame(
  sample = samples,
  caller = callers,
  vcf = vcfFiles,
  stringsAsFactors = FALSE
)
names(vcfInfo) <- c("sample", "caller", "vcf")

bamSamples <- strsplit(params$bamSamples, ",")
bamFiles <- strsplit(params$bamFiles, ",")

bamInfo <- data.frame(
  sample = bamSamples,
  bam = bamFiles,
  stringsAsFactors = FALSE
)
names(bamInfo) <- c("sample", "bam")

sampleData <- vcfInfo %>%
  left_join(bamInfo, by = "sample")
```


```{r run-summary-md, include=FALSE}
library(Gviz)
library(VariantAnnotation)
library(GenomicFeatures)
library(rtracklayer)
library(Biostrings)
library(tidyverse)
library(knitr)
out = NULL
for (index in 1:dim(sampleData)[[1]]) {
  genome <- params$genome
  variants <- file
  model <- params$genemodel
  sample <- sampleData[index,]$sample
  caller <- sampleData[index,]$caller
  vcffile <- sampleData[index,]$vcf
  bamfile <- sampleData[index,]$bam
  baseDir <- params$baseDir
  env = new.env()
  out = c(out, knit_child(paste0(baseDir, "/docs/loop_sample_variants.Rmd"), envir=env))
}
```

`r paste(out, collapse = '\n')`


## Read Based Consensus Phylogenetic Analysis


```{r parseTree, include=FALSE}
library(ggtree)
jmodel_bic <- read.tree(params$bicTree)
jmodel_aic <- read.tree(params$aicTree)
alignment <- readDNAMultipleAlignment(params$msaPhylip, format = "phylip")
```

Using the consensus sequences generated by comparing the reference to the combination of sample/variants analysis reported above, we have created a multiple alignment.
The alignment has then been used to compute the most informative tree, across a combination of alternative substitution matrices as well as topology methods.


### Akaike Information Criterion selection

The top ranking tree, according to the AIC score, is indicated below.

```{r AICtree, results='asis', echo=FALSE}
aic <- ggtree(jmodel_aic)+
  geom_tiplab()+
  geom_rootpoint(color = "black", size = 3)+
  geom_tippoint(color = "blue", alpha = .8, size = 3)
plot(aic)
```



### Bayesian Information Criterion selection

The top ranking tree, according to the BIC score, is presented below.


```{r BICtree, results='asis', echo=FALSE}
bic <- ggtree(jmodel_bic)+
  geom_tiplab()+
  geom_rootpoint(color = "black", size = 3)+
  geom_tippoint(color = "blue", alpha = .8, size = 3)
plot(bic)
```

We can also draw an overview of all sequence variation in the following MSA plot.

```{r MSAplot, results='asis', echo=FALSE}
msaplot(bic, fasta = params$msaFasta)
```




```{r SaveAll, include=FALSE}
save.image("analysis_report.RData")
```


# QC of the data

[here the various QC plots from Tom]


# Methods

## Reference Based Analysis

### Reference


### Alignment

The reads are trimmed for sequencing adapters and quality using *Cutadapt* [publication](http://journal.embnet.org/index.php/embnetjournal/article/view/200), using the following criteria:

- xxx
- yyy

Following the trimming, the reads are then aligned to the reference using *bwa-mem* [BWA manuscript](https://arxiv.org/abs/1303.3997), using default settings.


### Variant Calling and Filtering

**LoFreq Calling**

[describe here]

**iVar Calling**

The *iVar* workflow has been specifically developed to call variants within viral genomes when they are sequenced with amplicon approaches, and with the goal of reconstructing how viruses evolve within hosts.
The tool is therefore particularly suitable for the analysis when high-depth amplicon sequencing is performed, and when the identification of lower variant allele-fraction is necessary.
The tool allows removal of primers used for the amplification, calling variants in combination with *Samtools* and creating a consensus sequence.
[iVar Publication](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-018-1618-7)

During the iVar calling, loose thresholds are applied to variant identification in order to increase sensitivity and allow post-calling filtering for refining precision.
In particular, for the calling:

- allele-fraction threshold = 0.001
- read depth threshold = 10

In order to call the consensus sequence, based on the calling results, the following criteria are instead applied by default:

- allele-fraction threshold = 0.01
- read depth threshold = 100


**Variant Filters for Reporting**

In order to report the called variants, the following filters are applied on top of the basic calling performed by both LoFreq and iVar:

- allele-fraction threshold = [complete here]
- minimum alternative allele read depth = [complete here]


### Phylogenetic Analysis

**Multiple Sequence Alignment**

Once consensus sequences have been generated from the variant calling pipelines, the FASTA files are aligned all together using MUSCLE.

MUSCLE is a tool originally developed for creating multiple alignments of protein sequences. Elements of the algorithm include fast distance estimation using kmer counting, progressive alignment using a new profile function we call the log-expectation score, and refinement using tree-dependent restricted partitioning.
It produces alignments of competitive accuracy compared to other methods and emits results in several different formats: characteristics we found useful in the context of this pipeline.
[MUSCLE paper](https://pubmed.ncbi.nlm.nih.gov/15034147/)

**Computation of multiple trees**

In order to carry out the best tree computation and an unbiased selection of the most informative tree, we have used jModelTest2. jModelTest is a tool to carry out statistical selection of best-fit models of nucleotide substitution. It implements five different model selection strategies: hierarchical and dynamical likelihood ratio tests (hLRT and dLRT),
Akaike and Bayesian information criteria (AIC and BIC), and a decision theory method (DT). It also provides
estimates of model selection uncertainty, parameter importance and model-averaged parameter estimates, including model-averaged tree topologies.

In order to compute the trees we have used the following substitution schemes: JC/F81, K80/HKY, SYM/GTR.

Then, the tree topology has been defined as the best among the Nearest Neighbour Interchange and the Subtree Pruning and Regrafting with a Maximum-Likelihood search.[jModelTest2 publication](https://www.nature.com/articles/nmeth.2109)


**Selection of the best tree**

The Akaike information criterion (AIC, [Akaike, 1974] is an asymptotically unbiased estimator of the Kullback-
Leibler information quantity [S. Kullback, 1951]. We can think of the AIC as the amount of information lost
when we use a specific model to approximate the real process of molecular evolution. Therefore, the model
with the smallest AIC is preferred.

The AIC is computed as:

$AIC = -2l + 2k$

where l is the maximum log-likelihood value of the data under this model and Ki is the number of free
parameters in the model, including branch lengths if they were estimated de novo. When sample size (n) is
small compared to the number of parameters (say, nK < 40) the use of a second order AIC, AICc [Hurvich and
Tsai, 1989; Sugiura, 1978], is recommended:

$AIC_{c} = AIC + {(2k(k+1)) / (n-k-1)}$

The AIC compares several candidate models simultaneously, it can be used to compare both nested and
non-nested models, and model-selection uncertainty can be easily quantified using the AIC differences and
Akaike weights (see Model uncertainty below). Burnham and Anderson [2003] provide an excellent introduction
to the AIC and model selection in general.


An alternative to the use of the AIC is the Bayesian Information Criterion (BIC) [Schwarz, 1978]:

$BIC = -2l + klog(n)$

Given equal priors for all competing models, choosing the model with the smallest BIC is equivalent to
selecting the model with the maximum posterior probability. Alternatively, Bayes factors for models of molecular
evolution can be calculated using reversible jump MCMC [Huelsenbeck et al., 2004]. We can easily use the
BIC instead of the AIC to calculate BIC differences or BIC weights.


## Assembly Based Analysis
